<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <link rel="stylesheet" href="simple.css" />
  <link rel="stylesheet" href="style.css" />
  <title>Speech Tests</title>

  <script>
    const startAudio = async (audioCtx, volume_meter) => {
      audioCtx.audioWorklet.addModule('js/RecorderProcessor.js')
        .catch((err) => {
          console.log(`The following audioWorklet.addModule error occurred: ${err}`);
        })
        .then(() => {
          navigator.mediaDevices.getUserMedia({ audio: true })
            .catch((err) => {
              console.log(`The following mediaDevices.getUserMedia error occurred: ${err}`);
            })
            .then(stream => {
              const audioTracks = stream.getAudioTracks()
              if (audioTracks.length !== 1) {
                throw new Error('Too many tracks!')
              }
              const audioTrack = audioTracks[0]

              const recorder = audioCtx.createMediaStreamSource(stream)

              // const gain = audioCtx.createGain()
              // gain.gain.setValueAtTime(2, audioCtx.currentTime)

              // const compressor = audioCtx.createDynamicsCompressor()
              // compressor.threshold.setValueAtTime(-50, audioCtx.currentTime);
              // compressor.knee.setValueAtTime(40, audioCtx.currentTime);
              // compressor.ratio.setValueAtTime(20, audioCtx.currentTime);
              // compressor.attack.setValueAtTime(0, audioCtx.currentTime);
              // compressor.release.setValueAtTime(0.25, audioCtx.currentTime);

              const recorderWorklet = new AudioWorkletNode(audioCtx, 'recorder.worklet')

              var ws = new WebSocket(((window.location.protocol === "https:") ? "wss://" : "ws://") + window.location.host + "/transcribe_record/ws");
              ws.addEventListener('error', (e) => {
                console.log('WebSocket error: ', e)
              })
              ws.addEventListener('message', (e) => {
                obj = JSON.parse(e.data)
                src_lang.value = obj.language
                obj.segments.forEach(e => {
                  tgt_text.textContent += e.text + '\n'
                })
              })

              recorder.connect(recorderWorklet)
              // recorder.connect(compressor)
              // compressor.connect(recorderWorklet)
              recorderWorklet.connect(audioCtx.destination)

              const buffer_size = 16000 * 30
              const buffer = new Float32Array(buffer_size)
              let samples_written = 0

              recorderWorklet.port.onmessage = (e) => {
                if (typeof (e.data) === 'number') {
                  volume_meter.value = e.data // decibel
                  if (e.data <= -10) {
                    if (samples_written > 16000) {
                      console.log("Send after sentence end: " + samples_written)
                      ws.send(buffer.slice(0, samples_written))
                    }
                    samples_written = 0
                  }
                  return
                }
                msg_buffer = e.data
                console.log("Receiving audio data: " + msg_buffer.length + "(" + samples_written + ")")
                for (let i = 0; i < msg_buffer.length; i++) {
                  buffer[samples_written++] = msg_buffer[i]
                  if (samples_written === buffer_size) {
                    console.log("Send because buffer full " + samples_written)
                    ws.send(buffer.slice(0, samples_written))
                    samples_written = 0
                  }
                }
              }
            })
        })
    }

    window.onload = async () => {
      const btn_record = document.getElementById('button-start')
      const volume_meter = document.getElementById('volume-meter')
      const src_lang = document.getElementById('src_lang')
      const tgt_text = document.getElementById('tgt_text')

      btn_record.addEventListener('click', async () => {
        if (btn_record.textContent === 'Start recording') {
          audioCtx = new AudioContext()
          await startAudio(audioCtx, volume_meter)
          audioCtx.resume().then(() => {
            btn_record.textContent = "Recording... (Click stop for suspending record)";
          })
        } else if (audioCtx.state === "suspended") {
          audioCtx.resume().then(() => {
            btn_record.textContent = "Recording... (Click stop for suspending record)";
          })
        } else if (audioCtx.state === "running") {
          audioCtx.suspend().then(() => {
            btn_record.textContent = "Resume recording";
          })
        }
      })
      // init language dropdowns
      fetch('/languages', {
        headers: {
          'Accept': 'application/json'
        }
      })
        .then((res) => res.json())
        .then((json) => {
          for (let i = 0; i < json.length; i++) {
            const obj = json[i]
            const el = document.createElement('option')
            el.value = obj.language_id
            el.textContent = obj.language_name
            src_lang.appendChild(el)
          }
        })
        .catch(
          (error) => console.log(error)
        )

    }
  </script>
</head>

<body>
  <h1>Transcribe Recorder</h1>
  <p>In this demo you can speak into the micro and receive a transcription in real time. The recording snippets are sent
    to the server via websocket-based services, processed there and the response is sent back via websockets. The files
    are deleted immediately after processing.<br>
    This experiment isn't very stable yet, because of latency issues and wrong block sizes etc. Better use the record
    function in
    <a href="transcribe_upload.html">Transcribe Upload</a>.
  </p>
  <button id="button-start">Start recording</button>
  <input id="volume-meter" type="range" min="-20" max="80" value="-20" step="1" disabled>
  <label for="src_lang">Source language:</label>
  <select id="src_lang" disabled>
    <option value="">Will be autodetected...</option>
  </select>
  <label for="tgt_text">Transcription:</label>
  <pre id="tgt_text"></pre>
</body>

</html>